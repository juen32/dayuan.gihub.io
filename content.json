{"meta":{"title":"Dayuan's Blog.","subtitle":"it's better to burn out than to fade away","description":"我叫林大元，平常喜欢到处旅游走走，喜欢看NBA，喜欢喝喝小酒，打打游戏，喜欢一切科技以及新鲜的事物，希望大家多多指教o(∩_∩)o。","author":"lindayuan","url":"https://dayuan.tech"},"pages":[{"title":"","date":"2018-08-22T07:28:33.668Z","updated":"2018-08-22T07:28:33.668Z","comments":true,"path":"404.html","permalink":"https://dayuan.tech/404.html","excerpt":"","text":""},{"title":"","date":"2018-08-22T04:26:14.780Z","updated":"2018-08-22T04:26:14.780Z","comments":true,"path":"manifest.json","permalink":"https://dayuan.tech/manifest.json","excerpt":"","text":"{\"name\":\"Dayuan's Blog\",\"short_name\":\"dayuan\",\"icons\":[{\"src\":\"/img/icons/kumamon192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/img/icons/kumamon512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"start_url\":\"/?fr=pwahomescreen\",\"background_color\":\"#ffffff\",\"display\":\"standalone\",\"theme_color\":\"#000000\"}"},{"title":"About","date":"2018-08-22T06:34:49.066Z","updated":"2018-08-22T06:34:49.066Z","comments":true,"path":"about/index.html","permalink":"https://dayuan.tech/about/index.html","excerpt":"","text":"我叫林大元，平常喜欢到处旅游走走，喜欢看NBA，喜欢喝喝小酒，打打游戏，喜欢一切科技以及新鲜的事物，希望大家多多指教o(∩_∩)o。"},{"title":"Archives","date":"2017-07-30T12:49:56.000Z","updated":"2018-08-22T04:26:14.698Z","comments":false,"path":"archive/index.html","permalink":"https://dayuan.tech/archive/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-07-30T12:49:56.000Z","updated":"2018-08-22T04:26:14.781Z","comments":false,"path":"tags/index.html","permalink":"https://dayuan.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用Create-React-App添加css Modules、sasss和antd","slug":"使用create-react-app添加css modules、sasss和antd","date":"2018-08-20T17:03:59.000Z","updated":"2018-08-22T06:56:31.941Z","comments":true,"path":"article/使用create-react-app添加css modules、sasss和antd/","link":"","permalink":"https://dayuan.tech/article/使用create-react-app添加css modules、sasss和antd/","excerpt":"","text":"前言 create-react-app是facebook的官方脚手架，对于个人开发者和中小型公司快速创建项目非常推荐。react的CSS解决方案有很多，这里我技术选型时用css modules和sass，然后配合antd使用通用组件库。但是create-react-app原生并不支持css modules和sass，所以需要额外配置。 配置 增加css modules和sass 使用eject暴露配置 create-react-app默认是没有暴露webpack配置的，所以需要eject一下。注意如果项目在git仓库环境下，先提交代码到git仓库，否则会报错 1npm run eject npm添加css modules和sass 12npm install react-css-modules npm install sass-loader node-sass 这里安装sass可能会遇到墙的问题报错，所以要么使用cnpm或者使用本地代理设置，因为我有ss所以使用本地代理 1234// 开启代理npm config set proxy http://127.0.0.1:1080// 安装完sass后关闭代理npm config delete proxy webpack配置 重点来了，我们需要给webpack配置上css-modules和sass-loader。但是使用css-modules会使node_modules库里的css样式找不到，比如后面要使用到的antd，这个时候我们需要inclube来排除影响node_modules，使得css-modules不会影响到node_modules 修改项目中config目录下的webpack.config.dev.js和webpack.config.prod.js，说明下这两个文件，前一个是开发环境npm start使用，后一个是npm run build打包后使用 修改webpack.config.dev.js: 大约在160行左右，找到test: /\\.css$/，中文注释的地方就是修改和增加的地方 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&#123; test: [/\\.css$/, /\\.scss$/],// 这里增加SCSS的支持 exclude: [/node_modules/],// 这里去排除node_modules，防止css modules影响到node_modules use: [ require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, modules: true, // 这里增加对css modules的支持 localIdentName: '[name]__[local]__[hash:base64:5]' //这里增加对css modules的支持 &#125;, &#125;, &#123; loader: require.resolve('sass-loader'), // 这里增加sass的支持 &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, ],&#125;,// 因为上面排除了css_modules所以这里一定要再添加个排除src来识别css_modules// 其实就是复制之前没修改前的所有，再增加一个exclude: [/src/]&#123; test: /\\.css$/, exclude: [/src/], // 这里添加排除src， use: [ require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, ],&#125; 修改webpack.config.prod.js: 和上面修改webpack.config.dev.js类似 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&#123; test: [/\\.css$/, /\\.scss$/], // 这里增加SCSS的支持 exclude: [/node_modules/], // 这里去排除node_modules loader: ExtractTextPlugin.extract( Object.assign( &#123; fallback: &#123; loader: require.resolve('style-loader'), options: &#123; hmr: false, &#125;, &#125;, use: [ &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, minimize: true, sourceMap: true, modules: true, // 这里添加css modules支持 &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('sass-loader'), // 这里添加sass支持 &#125; ], &#125;, extractTextPluginOptions ) ), // Note: this won't work without `new ExtractTextPlugin()` in `plugins`. &#125;, &#123; test: /\\.css$/, exclude: [/src/], // 排除src loader: ExtractTextPlugin.extract( Object.assign( &#123; fallback: &#123; loader: require.resolve('style-loader'), options: &#123; hmr: false, &#125;, &#125;, use: [ &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, minimize: true, sourceMap: true, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125; ], &#125;, extractTextPluginOptions ) ), // Note: this won't work without `new ExtractTextPlugin()` in `plugins`. &#125; 安装antd和配置 主要是安装配置antd和babel-plugin-import，这样可以使得antd按需加载样式 npm添加antd和babel-plugin-import 12npm install antdnpm install babel-plugin-import 配置babel 在项目根目录下增加.babelrc文件，然后配置如下 123456789101112131415&#123; \"presets\": [ \"react-app\" ], \"plugins\": [ \"transform-runtime\", [ \"import\", &#123; \"libraryName\": \"antd\", \"style\": \"css\" &#125; ] ]&#125; 大功告成","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://dayuan.tech/tags/React/"}]},{"title":"Http请求","slug":"http请求","date":"2018-04-29T06:13:56.000Z","updated":"2018-08-22T06:41:00.405Z","comments":true,"path":"article/http请求/","link":"","permalink":"https://dayuan.tech/article/http请求/","excerpt":"","text":"Http请求的全过程 首先要了解HTTP请求头和相应头 HTTP请求request 请求行 请求头 空行 请求数据 请求行 包括请求类型，GET,POST,PUT,DELETE等，请求访问的资源，最后一部分说明使用的版本比如HTTP1.1 请求头部 请求头一般有以下部分组成 Accept 请求接受类型，比如text/javascript Accept-Encoding 压缩格式，比如gzip Accept-language 语言，比如zh-CN Accept-Charset 接受内容的字符集，utf-8 Cookie 用来保存一个登陆的用户信息，比如SeesionId 一些用户数据 Host 请求的主机域名 Referer 表示请求是从哪个URL来的 Cache-Control 控制是否需要缓存 User-Agent 用户代理，操作系统版本，浏览器及版本等 Connection: keep-alive 长连接HTTP1.1默认自带 websocket 连接 ws/wss Connection: Upgrade Upgrade: websocket 请求内容 get请求这里为空，post这里存放请求数据 HTTP响应response HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 状态行 HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 消息报头 Date 相应时间 Cache-control 缓存控制，max-age 相对过期时间 Content-Type 内容类型，比如text/html;charset=utf-8 Expires 过期时间 Etag 请求变量实体值 last-Modified 最后修改时间 请求过程详解 浏览器会先查询Cache-Conrol或者Expires，来查内容是否过期，如果未过期直接从缓存读取，不发送HTTP请求。否则进入下一步 进行域名解析，然后解析出端口号，默认80 ，浏览器建立一条与服务器的tcp连接（三次握手） 浏览器判断上次文件返回头中是否含有Etag信息，有则带上if-None-Match字段信息发送请求给服务端，服务端判断Etag未修改返回304，如果修改就返回200，否则进入下一步 浏览器判断上次文件返回头中是否含有Last-Modified，有则带上if-Modified-Since字段信息发送请求，服务端判断是否失效，有返回200，有效则返回304 服务端返回状态码 100：继续。客户端应继续其请求 101：切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议。websocket等 200：OK，请求成功 201：已创建。成功请求并创建了新的资源 202：已接受。已经接受请求，但未处理完成 300：重定向，多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301：永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303：查看其它地址。与301类似。使用GET和POST请求查看 304：未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 400：客户端请求的语法错误，服务器无法理解 401：请求要求用户的身份认证 403：服务器理解请求客户端的请求，但是拒绝执行此请求 404：服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面 406：请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 501：服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://dayuan.tech/tags/http/"}]},{"title":"性能优化","slug":"性能优化","date":"2018-04-25T12:48:00.000Z","updated":"2018-08-22T06:41:00.405Z","comments":true,"path":"article/性能优化/","link":"","permalink":"https://dayuan.tech/article/性能优化/","excerpt":"","text":"Web前端性能优化 桌面端优化 减少HTTP资源请求数 透过构建工具合并雪碧图、CSS、JS文件。来减少资源的请求，避免重复的资源。 减少HTTP请求大小 除了减少资源次数，也要尽量减小每个HTTP请求的大小。使用gzip压缩传输内容。 将CSS或JavaScript放到外部文件中，避免使用style或script标签直接引入 在HTML文件中应用外部资源可以有效的利用浏览器的静态资源缓存 123&lt;link rel=\"stylesheet\" href=\"//cdn.domain.com/path/main.css\"&gt;...&lt;script src=\"//cdn.domain.com/path/main.js\"&gt;&lt;/script&gt; 为HTML制定Cache-Control或Expires 为HTML内容设置Cache-Control或者Expires可以将HTML内容缓存起来,在页面的Cache-Control或Expires头部有效的时候，浏览器直接从缓存中读取内容。 设置Etag和Last-Modified 合理设置Etag和last-Modified使用浏览器缓存，对于未修改的文件，静态资源服务器会向浏览器返回304，让浏览器从缓存中读取文件。 减少页面重定向 页面每次重定向都会延迟页面内容返回等待时间，一次重定向大约需要600ms的时间开销，为了保证用户尽快看到页面内容，要竟然避免重定向 使用静态资源分域存放增加下载并行数 浏览器在同一时刻向同一个域名请求文件的并行下载数是有限的，因此可以利用多个域名的主机来存放不同的静态资源，增大页面的加载时资源的并行下载数，缩短页面资源加载的时间。通常根据多个域名来分别存储javaScirpt、CSS和图片文件。 使用静态资源CDN来存储文件 如果条件允许，可以利用CDN网络加快同一个地理区域内重复静态资源文件的响应下载速度，缩短资源请求时间。 使用CDN Combo 下载传输内容 CDN Combo是在CDN服务器端将多个文件请求打包成个一个文件的形式来返回的技术，这样可以实现HTTP连接传输的一次性复用，减少浏览器的HTTP请求速，加快资源下载的速度。 1&lt;script src=\"//cdn.domain.com/path/a.js,b.js,c.js\"&gt;&lt;/script&gt; 使用可缓存的AJAX 对于返回内容相同的请求，没必要每次都直接从服务端拉取，合理使用AJAX缓存能加快AJAX响应速度并减轻服务器的压力。 使用GET来完成AJAX请求 使用XMLHttpRequest时，浏览器中的POST方法请求首先发送头文件，再发送HTTP正文数据。而使用GET的时只发送头部，所以在拉取服务端数据的时使用Get请求效率更高。 减少Cookie的大小并进行Cookie隔离 HTTP请求通常默认带上浏览器端的Cookie一起发送给服务端，所以在非必要的情况下，要尽量减少Cookie来减小HTTP请求大小。对于静态资源，尽量使用不同的域名来存放，因为Cookie默认是不能跨域的，这样就做到了不同域名下静态资源请求的Cookie隔离。 推荐使用异步JavaScript资源 异步的JavaScript资源不会阻塞文档解析，所以允许在浏览器中优先渲染界面，延后加载脚本执行。例如JavaScript的引用可以如下设置，也可以使用模块化加载机制来实现。 12&lt;script src=\"main.js\" defer&gt;&lt;/script&gt;&lt;script src=\"main.js\" async&gt;&lt;/script&gt; 消除阻塞渲染的CSS及Javacript 对于页面中加载时间过长的SCC或JavaScript文件，需要进行合理的拆分或延后加载，保证关键路径的资源能快速的加载完成。 避免使用CSS import引用加载Css CSS中的＠import可以从另一个样式文件中引入样式，但应该避免这种用法，因为这样会增加CSS资源加载的关键路径长度，带有＠import的CSS样式需要在CSS文件串行解析到@import时才会加载另外的CSS文件，大大延后CSS渲染完成的时间。 123456&lt;!-- 不推荐 --&gt;&lt;style&gt;@import \"path/main.css\";&lt;/style&gt;&lt;!-- 推荐 --&gt;&lt;link rel=\"stylesheet\" href=\"//cdn1.domain.com/path/main.css\"&gt; 渲染优化 把CSS资源引用放到HTML文件顶部 一般推荐将所有CSS资源尽早指定在HTML文档的中，这样浏览器可以优先下载CSS并尽早完成页面的渲染 JavaScript资源引用放到HTML文件底部 减少DOM元素的数量和深度 尽量避免使用 等慢元素","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://dayuan.tech/tags/性能优化/"}]},{"title":"ES6设计模式 设计原则","slug":"ES6设计模式-设计原则","date":"2018-04-08T13:57:04.000Z","updated":"2018-08-22T06:44:36.157Z","comments":true,"path":"article/ES6设计模式-设计原则/","link":"","permalink":"https://dayuan.tech/article/ES6设计模式-设计原则/","excerpt":"","text":"ES6的设计模式 最近看了《javascript高级程序设计》表示很有收获，但是其整篇文章都是用ES5写的，所以我打算对其整理下，并用ES6进行重写。 设计模式6大原则 先了解设计原则 单一职责原则 应该有且只有一个原因引起类的变化，包括方法和接口 里氏替换原则 只要父类出现的地方子类就一定可以出现，而且替换为子类也不会出现异常。但是子类出现的地方，不一定能使用父类。 依赖倒置原则 高层模块不应该依赖底层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 接口隔离原则 客户端不应该依赖他不需要的接口 最少知识原则 一个对象应该对其他对象有最少的了解 开闭原则 对拓展开放，对修改关闭，其他五个原则的基石","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://dayuan.tech/tags/设计模式/"}]},{"title":"React生命周期详解","slug":"React生命周期详解","date":"2018-04-06T09:06:19.000Z","updated":"2018-08-22T06:50:53.486Z","comments":true,"path":"article/React生命周期详解/","link":"","permalink":"https://dayuan.tech/article/React生命周期详解/","excerpt":"","text":"React生命周期图解 详细说明 生命周期包含4种情况：组件初始化装载时候，组件属性改变时候，组件状态改变时候，组件被销毁时候 生命周期共提供了10个不同的API。 defaultProps ES6使用defaultProps()方法，ES5中getDefaultProps()方法。只调用一次，返回对象用于设置默认的props，但是对于引用值会在各个实例中共享。 constructor(props) 构造函数，实例创建的时候调用，主要为了初始化state或绑定this，ES5中用getInitialState() componentWillMount() 第一次渲染阶段在调用render方法前会调用，此时仍然可以修改组件的state render() 必选方法，创建虚拟DOM，该方法具有特殊规则： 只能通过this.props和this.state访问数据 可以返回null、false或任何React组件 只能出现一个顶级组件（不能返回数组） 不能改变组件的状态state 不能修改DOM的输出 componentDidMount 首次装载渲染完成，真实的DOM被渲染出来后调用，可以做一些依赖DOM的操作，比如利用refs获取DOM。子组件比父组件优先渲染，所以可以获取子组件对应的DOM。 注意：在服务端中，该方法不会被调用！ componentWillReciveProps(nextProps) 组件接受到新的props时候调用，此时可以根据nextProps来修改state。 注意：这个时候虽然说是获取新的属性，但是并不能保证属性一定发生了改变。 shouldComponentUpdate(nextProps, nextState) 接受到新的属性或者新的状态的时候在render前会被调用。除了调用forceUpdate和初始化渲染以外。 该方法让我们有机会决定是否重新渲染组件，返回false，那么不会重新渲染组件，借此可以优化性能，除非特殊情况比如在组件很多性能瓶颈，大多数情况不推荐使用。 componentWillUpdate(nextProps, nextState) 当组件确定要更新，render之前被调用。 这个时候可以确定一定会更新组件，可以执行更新前的操作。此时不能更新修改state和props！ componentDitUpdate() 完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。 componentWillUnmount() 组件被卸载之前调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://dayuan.tech/tags/React/"}]}]}